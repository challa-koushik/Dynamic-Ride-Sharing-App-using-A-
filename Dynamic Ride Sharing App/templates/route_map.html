{% extends "base.html" %}

{% block title %}Route Map{% endblock %}

{% block content %}
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        background: #f5f7fa;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 24px;
    }
    
    .header-section {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 24px 32px;
        border-radius: 16px;
        margin-bottom: 24px;
        color: white;
        box-shadow: 0 8px 24px rgba(102, 126, 234, 0.25);
    }
    
    .header-section h2 {
        font-size: 28px;
        margin-bottom: 8px;
    }
    
    .route-details {
        font-size: 16px;
        opacity: 0.95;
    }
    
    /* Rider Notification Banner */
    .rider-notification {
        margin-bottom: 24px;
    }
    
    .rider-info-banner {
        background: linear-gradient(135deg, #10b981, #059669);
        padding: 20px 24px;
        border-radius: 16px;
        display: flex;
        align-items: center;
        gap: 20px;
        color: white;
        box-shadow: 0 8px 24px rgba(16, 185, 129, 0.3);
        animation: slideInDown 0.5s ease;
    }
    
    @keyframes slideInDown {
        from {
            opacity: 0;
            transform: translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .rider-avatar-circle {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 36px;
        border: 4px solid white;
        flex-shrink: 0;
    }
    
    .rider-details-banner {
        flex: 1;
    }
    
    .rider-details-banner h3 {
        margin: 0 0 8px 0;
        font-size: 22px;
        font-weight: 700;
    }
    
    .rider-details-banner p {
        margin: 0;
        font-size: 16px;
        opacity: 0.95;
    }
    
    .rider-status-badge {
        padding: 12px 24px;
        background: white;
        color: #10b981;
        border-radius: 24px;
        font-weight: 700;
        font-size: 16px;
        flex-shrink: 0;
    }
    
    .route-info {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
    }
    
    .info-card {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        display: flex;
        align-items: center;
        gap: 16px;
    }
    
    .info-icon {
        font-size: 32px;
        width: 56px;
        height: 56px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #f3f4f6;
        border-radius: 12px;
    }
    
    .info-content {
        flex: 1;
    }
    
    .info-label {
        font-size: 13px;
        color: #6b7280;
        margin-bottom: 4px;
    }
    
    .info-value {
        font-size: 20px;
        font-weight: 700;
        color: #1f2937;
    }
    
    .path-section {
        background: white;
        padding: 24px;
        border-radius: 12px;
        margin-bottom: 24px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }
    
    .path-title {
        font-size: 16px;
        font-weight: 600;
        color: #1f2937;
        margin-bottom: 16px;
    }
    
    .path-cities {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
    }
    
    .city-badge {
        padding: 12px 24px;
        background: #2563eb;
        color: white;
        border-radius: 24px;
        font-size: 16px;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        box-shadow: 0 2px 4px rgba(37, 99, 235, 0.3);
    }
    
    .city-badge::after {
        content: '‚Üí';
        margin-left: 8px;
        font-size: 20px;
        color: rgba(255, 255, 255, 0.7);
    }
    
    .city-badge:last-child::after {
        content: '';
    }
    
    #map {
        width: 100%;
        height: 600px;
        border-radius: 16px;
        border: 2px solid #e5e7eb;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        margin-bottom: 24px;
    }
    
    .btn-back {
        display: inline-block;
        padding: 14px 28px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        text-decoration: none;
        border-radius: 10px;
        font-weight: 600;
        transition: all 0.3s;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    
    .btn-back:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
    }
    
    .loading-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 24px 32px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        display: none;
    }
    
    .loading-overlay.show {
        display: block;
    }
</style>

<div class="container">
    <div class="header-section">
        <h2>üöó Your Route: {{ source }} ‚Üí {{ destination }}</h2>
        <p class="route-details">
            {% if status == 'accepted' %}
                ‚úÖ Ride Accepted - Driver on the way!
            {% elif status == 'pending' %}
                ‚è≥ Searching for driver...
            {% else %}
                Optimized route with real road paths
            {% endif %}
        </p>
    </div>
    
    <!-- Rider Notification (only if accepted) -->
    {% if status == 'accepted' and rider %}
    <div class="rider-notification">
        <div class="rider-info-banner">
            <div class="rider-avatar-circle">
                üèçÔ∏è
            </div>
            <div class="rider-details-banner">
                <h3>{{ rider.name }} is coming to pick you up!</h3>
                <p>üìç Distance from pickup: {{ rider.distance_to_pickup }} km</p>
            </div>
            <div class="rider-status-badge">
                ‚úì On the way
            </div>
        </div>
    </div>
    {% endif %}
    
    <div class="route-info">
        <div class="info-card">
            <div class="info-icon">üìè</div>
            <div class="info-content">
                <div class="info-label">Total Distance</div>
                <div class="info-value" id="totalDistance">Calculating...</div>
            </div>
        </div>
        
        <div class="info-card">
            <div class="info-icon">‚è±Ô∏è</div>
            <div class="info-content">
                <div class="info-label">Estimated Time</div>
                <div class="info-value" id="estimatedTime">Calculating...</div>
            </div>
        </div>
        
        <div class="info-card">
            <div class="info-icon">üõ£Ô∏è</div>
            <div class="info-content">
                <div class="info-label">Waypoints</div>
                <div class="info-value">{{ path|length }}</div>
            </div>
        </div>
    </div>
    
    <div class="path-section">
        <div class="path-title">üìç Route via Cities:</div>
        <div class="path-cities">
            {% for city in path %}
            <div class="city-badge">{{ city }}</div>
            {% endfor %}
        </div>
    </div>
    
    <div style="position: relative;">
        <div id="map"></div>
        <div class="loading-overlay" id="loadingOverlay">
            <div style="text-align: center;">
                <div style="font-size: 32px; margin-bottom: 12px;">üó∫Ô∏è</div>
                <div style="font-weight: 600; color: #1f2937;">Loading real road routes...</div>
            </div>
        </div>
    </div>
    
    <div style="text-align: center;">
        <a href="{{ url_for('user_dashboard') }}" class="btn-back">
            ‚Üê Back to Dashboard
        </a>
    </div>
</div>

<!-- OpenLayers -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.2.1/ol.css">
<script src="https://cdn.jsdelivr.net/npm/ol@v10.2.1/dist/ol.js"></script>

<script>
const source = "{{ source }}";
const destination = "{{ destination }}";
const path = {{ path|tojson }};
const coords = {{ coords|tojson }};
const rideStatus = "{{ status }}";
const riderData = {{ rider|tojson if rider else 'null' }};

console.log('üìç Route:', path);
console.log('üó∫Ô∏è Coordinates:', coords);
console.log('üìä Status:', rideStatus);
console.log('üèçÔ∏è Rider:', riderData);

// Initialize map
const map = new ol.Map({
    target: 'map',
    layers: [
        new ol.layer.Tile({
            source: new ol.source.OSM()
        })
    ],
    view: new ol.View({
        center: ol.proj.fromLonLat([coords[0][1], coords[0][0]]),
        zoom: 9
    })
});

// Create vector layer for markers and route
const vectorSource = new ol.source.Vector();
const vectorLayer = new ol.layer.Vector({
    source: vectorSource,
    zIndex: 10
});
map.addLayer(vectorLayer);

// Add source marker (green)
const sourceMarker = new ol.Feature({
    geometry: new ol.geom.Point(ol.proj.fromLonLat([coords[0][1], coords[0][0]]))
});

sourceMarker.setStyle(new ol.style.Style({
    image: new ol.style.Circle({
        radius: 12,
        fill: new ol.style.Fill({ color: '#10b981' }),
        stroke: new ol.style.Stroke({ color: 'white', width: 3 })
    }),
    text: new ol.style.Text({
        text: 'üöÄ',
        font: '18px sans-serif',
        offsetY: -25
    })
}));

vectorSource.addFeature(sourceMarker);

// Add destination marker (red)
const destCoord = coords[coords.length - 1];
const destMarker = new ol.Feature({
    geometry: new ol.geom.Point(ol.proj.fromLonLat([destCoord[1], destCoord[0]]))
});

destMarker.setStyle(new ol.style.Style({
    image: new ol.style.Circle({
        radius: 12,
        fill: new ol.style.Fill({ color: '#ef4444' }),
        stroke: new ol.style.Stroke({ color: 'white', width: 3 })
    }),
    text: new ol.style.Text({
        text: 'üéØ',
        font: '18px sans-serif',
        offsetY: -25
    })
}));

vectorSource.addFeature(destMarker);

// Add intermediate waypoint markers
for (let i = 1; i < coords.length - 1; i++) {
    const waypoint = new ol.Feature({
        geometry: new ol.geom.Point(ol.proj.fromLonLat([coords[i][1], coords[i][0]]))
    });
    
    waypoint.setStyle(new ol.style.Style({
        image: new ol.style.Circle({
            radius: 8,
            fill: new ol.style.Fill({ color: '#3b82f6' }),
            stroke: new ol.style.Stroke({ color: 'white', width: 2 })
        })
    }));
    
    vectorSource.addFeature(waypoint);
}

// Fetch real road route using OSRM
async function drawRealRoute() {
    document.getElementById('loadingOverlay').classList.add('show');
    
    try {
        // Build coordinate string for OSRM
        const coordString = coords.map(coord => `${coord[1]},${coord[0]}`).join(';');
        
        // Call OSRM API
        const response = await fetch(
            `https://router.project-osrm.org/route/v1/driving/${coordString}?overview=full&geometries=geojson&steps=true`
        );
        
        const data = await response.json();
        
        if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
            const route = data.routes[0];
            const routeCoords = route.geometry.coordinates;
            
            // Convert to OpenLayers format
            const lineCoords = routeCoords.map(coord => ol.proj.fromLonLat(coord));
            
            // Draw main route line
            const routeLine = new ol.Feature({
                geometry: new ol.geom.LineString(lineCoords)
            });
            
            routeLine.setStyle(new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: '#4f46e5',
                    width: 5,
                    lineCap: 'round',
                    lineJoin: 'round'
                })
            }));
            
            vectorSource.addFeature(routeLine);
            
            // Add route outline for better visibility
            const routeOutline = new ol.Feature({
                geometry: new ol.geom.LineString(lineCoords)
            });
            
            routeOutline.setStyle(new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: 'rgba(79, 70, 229, 0.3)',
                    width: 9,
                    lineCap: 'round',
                    lineJoin: 'round'
                }),
                zIndex: -1
            }));
            
            vectorSource.addFeature(routeOutline);
            
            // Update distance and time
            const distanceKm = (route.distance / 1000).toFixed(1);
            const timeMin = Math.round(route.duration / 60);
            const timeHr = Math.floor(timeMin / 60);
            const timeRem = timeMin % 60;
            
            document.getElementById('totalDistance').textContent = `${distanceKm} km`;
            
            if (timeHr > 0) {
                document.getElementById('estimatedTime').textContent = `${timeHr}h ${timeRem}min`;
            } else {
                document.getElementById('estimatedTime').textContent = `${timeMin} min`;
            }
            
            console.log(`‚úÖ Real road route loaded: ${distanceKm} km, ${timeMin} min`);
            
        } else {
            console.error('OSRM returned no routes');
            drawFallbackRoute();
        }
        
    } catch (error) {
        console.error('Error fetching OSRM route:', error);
        drawFallbackRoute();
    } finally {
        document.getElementById('loadingOverlay').classList.remove('show');
    }
}

function drawFallbackRoute() {
    // Fallback: Draw straight line if OSRM fails
    const lineCoords = coords.map(coord => ol.proj.fromLonLat([coord[1], coord[0]]));
    
    const routeLine = new ol.Feature({
        geometry: new ol.geom.LineString(lineCoords)
    });
    
    routeLine.setStyle(new ol.style.Style({
        stroke: new ol.style.Stroke({
            color: '#4f46e5',
            width: 4,
            lineDash: [10, 5]
        })
    }));
    
    vectorSource.addFeature(routeLine);
    
    // Estimate distance and time
    let totalDist = 0;
    for (let i = 0; i < coords.length - 1; i++) {
        const lat1 = coords[i][0], lon1 = coords[i][1];
        const lat2 = coords[i+1][0], lon2 = coords[i+1][1];
        totalDist += haversineDistance(lat1, lon1, lat2, lon2);
    }
    
    document.getElementById('totalDistance').textContent = `${totalDist.toFixed(1)} km`;
    document.getElementById('estimatedTime').textContent = `${Math.round(totalDist * 1.5)} min`;
    
    console.log('‚ö†Ô∏è Using fallback route');
}

function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

// Add rider location and route if ride is accepted
if (rideStatus === 'accepted' && riderData) {
    console.log('‚úÖ Ride accepted! Showing rider location:', riderData);
    
    // Add rider marker (green with bike emoji)
    const riderMarker = new ol.Feature({
        geometry: new ol.geom.Point(ol.proj.fromLonLat([riderData.lon, riderData.lat]))
    });
    
    riderMarker.setStyle(new ol.style.Style({
        image: new ol.style.Circle({
            radius: 14,
            fill: new ol.style.Fill({ color: '#10b981' }),
            stroke: new ol.style.Stroke({ color: 'white', width: 3 })
        }),
        text: new ol.style.Text({
            text: 'üèçÔ∏è',
            font: '20px sans-serif',
            offsetY: -30
        })
    }));
    
    vectorSource.addFeature(riderMarker);
    
    // Draw route from rider to pickup point
    drawRiderToPickupRoute(riderData.lat, riderData.lon, coords[0][0], coords[0][1]);
}

async function drawRiderToPickupRoute(riderLat, riderLon, pickupLat, pickupLon) {
    try {
        // Use OSRM to get real road route from rider to pickup
        const coordString = `${riderLon},${riderLat};${pickupLon},${pickupLat}`;
        
        const response = await fetch(
            `https://router.project-osrm.org/route/v1/driving/${coordString}?overview=full&geometries=geojson`
        );
        
        const data = await response.json();
        
        if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
            const route = data.routes[0];
            const routeCoords = route.geometry.coordinates;
            const lineCoords = routeCoords.map(coord => ol.proj.fromLonLat(coord));
            
            // Draw dashed line for rider's approach route
            const riderRoute = new ol.Feature({
                geometry: new ol.geom.LineString(lineCoords)
            });
            
            riderRoute.setStyle(new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: '#10b981',
                    width: 4,
                    lineDash: [10, 10]
                })
            }));
            
            vectorSource.addFeature(riderRoute);
            
            console.log('‚úÖ Rider-to-pickup route drawn');
            
            // Fit map to show all markers
            const extent = vectorSource.getExtent();
            map.getView().fit(extent, {
                padding: [80, 80, 80, 80],
                duration: 1000
            });
        }
    } catch (error) {
        console.error('Error drawing rider route:', error);
    }
}

// Draw the route with real roads
drawRealRoute().then(() => {
    // Fit map to show all markers after main route is drawn
    if (rideStatus !== 'accepted' || !riderData) {
        const extent = vectorSource.getExtent();
        map.getView().fit(extent, {
            padding: [50, 50, 50, 50],
            duration: 1000
        });
    }
});

// Auto-refresh if ride is pending (waiting for rider)
if (rideStatus === 'pending') {
    console.log('‚è≥ Ride pending - will refresh in 1 seconds to check for rider');
    setTimeout(() => {
        console.log('üîÑ Refreshing to check for updates...');
        window.location.reload();
    }, 1000);
}

console.log('‚úÖ Route map initialized with real roads');
</script>

{% endblock %}